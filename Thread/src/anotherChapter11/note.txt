第11章 性能与可伸缩性

11.1 对性能的思考
    提升性能意味着用更少的资源做更多的事情。尽管使用多个线程的目标是提升整体性能，但与单线程的方法相比，使用多个线程总会引起
一些额外的性能开销。造成这些开销的操作包括：线程之间的协调(例如加锁、触发信号以及内存同步等)，增加的上下文切换，线程的创建和销毁，
以及线程的调度等。如果过度地使用线程，那么这些开销甚至会超过提高吞吐量、响应性或者计算能力所带来的性能提升。另一方面，一个并发设计
很糟糕的应用程序，其性能甚至比实现相同的串行程序的性能还要差。
    要想通过并发来获得更好的性能，需要努力做好两件事：更有效地利用现有处理资源，以及在出现新的处理资源时尽可能地利用这些新资源。

11.1.1 性能和可伸缩性
    可伸缩性是指：当增加计算资源时(例如CPU、内存、存储容量或I/O带宽)，程序的吞吐量或者处理能力能相应地增加。
    在进行可伸缩性调优时，其目的是设法将问题的计算并行化，从而能利用更多的计算资源来完成更多的工作。

    在所有并发程序中都包含一些串行部分。如果你认为在你的程序中不存在串行部分，那么可以再仔细检查一遍。

11.3.1 上下文切换

11.4 减少锁的竞争
    在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。

    有三种方式可以降低锁的竞争程度
    1、减少锁的持有时间
    2、降低锁的请求频率
    3、使用带有协调机制的独占锁，这些机制允许更高的并发性

    11.4.1 缩小锁的范围("快进快出")
    降低发生竞争可能性的一种有效方式就是尽可能缩短锁的持有时间。例如，可以将一些与锁无关的代码移出同步代码块，尤其是那些开销较大的
操作，以及可能被阻塞的操作，例如I/O操作。

    11.4.2 减小锁的粒度
    另一种减小锁的持有时间的方式是降低线程请求锁的频率(从而减小发生竞争的可能性)。这可以通过锁分解和锁分段等技术实现，在这些技术中将
采用多个相互独立的锁来保护的状态变量，从而改变这些变量在之前由单个锁来保护的情况。这些技术能减小操作的粒度，并能实现更高的可伸缩性，
然而，使用的锁越多，那么发生死锁的风险也就越高。
    设想一下，如果在整个应用程序中只有一个锁，而不是为每个对象分配一个独立的锁，那么，所有同步代码块的执行就会变成串行化执行，而不考虑
各个同步块中的锁。由于很多线程将竞争同一个全局锁，因此两个线程同时请求这个锁的概率将剧增，从而导致更严重的竞争。所以如果将这些锁请求分布
到更多的锁上，那么能有效地降低竞争程度。由于等待锁而被阻塞的线程将更少，因此可伸缩性将提高。
    如果一个锁需要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁
被请求的频率。

    11.4.3 锁分段

11.6 减少上下文切换的开销
    在很多任务中都包含一些可能被阻塞的操作。当任务在运行和阻塞这两个状态之间转换时，就相当于一次上下文切换。