8.1 在任务与执行策略之间的隐性耦合
    只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳。如果将运行时间较长的与运行时间较短的任务混合在一起，那么
除非线程池很大，否则将可能造成"拥塞"。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则可能造成死锁。

8.1.1 线程饥饿死锁
    在线程池中，如果任务依赖于其他任务，那么可能产生死锁。在单线程的Executor中，如果一个任务将另一个任务提交到同一个
Executor，并且等待这个被提交任务的结果，那么通常会引发死锁。第二个任务停留在工作队列中，并等待第一个任务完成，而第一个
任务又无法完成，因为它在等待第二个任务的完成。在更大的线程池中，如果所有正在执行任务的线程都由于等待其他仍处于工作队列中
的任务而阻塞，那么会发生同样的问题。这种现象被称为饥饿死锁。

8.3.2 管理队列任务
    只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或队列就可能导致
线程"饥饿"死锁问题。此时应该使用无界的线程池，例如newCachedThreadPool

    在有限的线程池中会限制可并发执行的执行数量.(单线程的Executor是一种值得注意的特例：它们能确保不会有任务并发执行，因为它们能
通过线程封闭来实现线程安全性)注意括号里的话

    如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个Runnable和一个链表节点来
表现一个等待中的任务，当然比使用线程来表示的开销低很多，但如果客户提交给服务器请求的速率超过了服务器的处理速率，那么仍可能会耗尽资源。

    ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方法有三种：无界队列、有界队列和同步移交(Synchronous HandOff).
队列的选择与其他的配置参数有关。例如线程池的大小等。

public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue)使用给定的初始参数和默认线程工厂创建一个新的ThreadPoolExecutor ，并拒绝执行处理程序。 使用Executors工厂方法之一可能更方便，而不是这种通用构造函数。
参数
corePoolSize - 即使空闲时仍保留在池中的线程数，除非设置 allowCoreThreadTimeOut
maximumPoolSize - 池中允许的最大线程数
keepAliveTime - 当线程数大于核心时，这是多余的空闲线程在终止之前等待新任务的最大时间。
unit - keepAliveTime参数的时间单位
workQueue - 在执行任务之前用于保存任务的队列。 该队列将仅保存execute方法提交的Runnable任务。

