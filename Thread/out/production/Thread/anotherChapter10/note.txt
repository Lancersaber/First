第10章 避免活跃性问题

10.1.3 在协作对象之间发生的死锁
    如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能会获取其他锁(这可能会产生死锁)，或阻塞时间过长，导致其他线程
无法及时获得当前被持有的锁。

10.1.4 开放调用
    如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。
    在程序中应尽量使用开放调用。与那些在持有锁时调用外部方法的程序相比，更易于对依赖于开放调用的程序进行死锁分析。

10.3 其他活跃性危险
    10.3.1 饥饿
    当线程由于无法访问它所需要的资源而不能继续执行时，就发生了"饥饿(Starvation)".引发饥饿的最常见的资源就是CPU时钟周期。如果
在Java应用程序中对线程的优先级使用不当，或者在持有锁时执行一些无法结束的结构(例如无限循环，或者无限制地等待某个资源)，那么也可能
导致饥饿，因为其他需要这个锁的线程将无法得到它。
    通常，我们尽量不要改变线程的优先级，只要改变了线程的优先级，程序的行为就将与平台相关，并且会导致发生饥饿问题的风险。你经常能
发现某个程序会在一些奇怪的地方调用Thread.sleep或Thread.yield,这是因为该程序试图克服优先级调整问题或响应问题，并试图让低优先级的
线程执行更多的时间。

    10.3.2 糟糕的响应性

    10.3.3 活锁
    活锁(Livelock)是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。
