1、ConcurrentHashMap
    同步容器类在执行每个操作期间都持有一个锁。在一些操作中，例如HashMap.get或List.contains,可能会包含大量的工作。
当在执行耗时很长的操作时，其他线程在这段时间都不能访问该容器。这会导致并发性下降。
    与HashMap一样，ConcurrentHashMap也是一个基于散列的Map，但它使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性。
ConcurrentHashMap并不是将每个都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更
大程度的共享，这种机制称为分段锁(Lock Striping).在这种机制中，任意数量的读取线程可以并发地访问Map，执行读取操作的线程和执
行写入操作可以并发地访问Map，并且一定数量的写入线程可以并发修改Map。ConcurrentHashMap带来的结果是，在并发的环境下将实现更
高的吞吐量，而在单线程环境中只损失非常小的性能。

2、CopyOnWriteArrayList

3、BlockingQueue
   阻塞队列支持生产者-消费者这种设计模式。该模式将"找出需要完成的工作"与"执行工作"这两个过程分离开，并把工作项放入一个"待完成"
列表中以便在随后处理，而不是找出后立即处理。

4、Deque
    Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。具体实现包含ArrayDeque和LinkedBlockingDeque
    双端队列适用于工作密取模式(Work Stealing).在生产者-消费者设计中。所有消费者有一个共享的工作队列，而在工作密取
设计中，每个消费者都有自己各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端
队列尾部秘密地获取工作。密取工作模式比传统的生产者-消费者模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享的
任务队列上发生竞争。在大多时候，它们都只是访问自己的双端队列，从而极大地减少了竞争。

5、同步工具类
    信号量 Semaphore
    栅栏 Barrier
    闭锁 Latch
         FutureTask

    5.1 闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门
一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变
状态，因此这扇门将保持打开状态。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。

    5.2 FutureTask也可以用作闭锁。(FutureTask实现了Future语义，表示一种抽象的可生成结果的计算)。FutureTask表示的计算是通过
Callable来实现的，相当于一种可生成结果的Runnable。
    Future.get的行为取决于任务的状态。如果任务已经完成，那么get会立即返回结果，否则get将阻塞直到任务进入完成状态，然后返回结果
或者抛出异常。FutureTask将计算结果从执行计算的线程传递到获取这个结果的线程，而FutureTask的规范确保了这种传递过程能获取这个结果的
线程。
    FutureTask使用简介：传入一个Callable<V>,这个FutureTask在运行时(FutureTask实现了Runnable接口)会执行给定的Callable,然后通过
FutureTask的get方法获得结果。

    5.3 计数信号量(Counting Semaphore)用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。
    Semaphore中管理者一组虚拟的许可(permit),许可的初始数量可通过构造函数来指定。在执行操作时可以先获得许可(permit),许可的初始数量
可通过以后释放许可。如果没有许可，那么acquire将阻塞直到有许可(或者直到被中断或者操作超时)。release方法将返回一个许可信号量。

    5.4 栅栏(Barrier)类似于闭锁，它能阻塞一组线程知道某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续
执行。闭锁用于等待事件，而栅栏用于等待其他线程。栅栏用于实现一些协议，例如几个家庭决定在某个地方集合："所有人6：00在麦当劳碰头，到了
以后要等待其他人，之后再讨论下一步要做的事情。"
    当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时
所有线程都被释放，而栅栏将被重置以便下次使用。如果对await的调用超时，或者await阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的
await调用都将终止并抛出BrokenBarrierException。